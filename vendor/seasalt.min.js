class SeaSalt_Common{constructor(config){this.config={algorithm:"xchacha",secret:"changeme3xg4#",pwhash:"argon2",pwsecurity:"normal"};this.state={ready:false,aead:false};if(["argon2","scrypt"].indexOf(this.config.pwhash)===-1)this.config.pwhash="argon2";if(typeof config==="object")for(let i in config)if(config.hasOwnProperty(i))this.config[i]=config[i];if(typeof this.config.logger==="undefined")this.config.logger=console.log;this.pwhash={};this.pwhash.argon2=new SeaSalt_PWHash_Argon2;this.pwhash.scrypt=
new SeaSalt_PWHash_SCrypt;this.tools=new SeaSalt_Tools(this.config);this.secretbox=new SeaSalt_AEAD_SecretBox(this.config);this.aead={};this.aead.xchacha=new SeaSalt_AEAD_XChaCha(this.config);this.hash=new SeaSalt_Hashing;if(sodium){this.config.logger("SeaSalt - Loaded successfully");this.state.ready=true;this.state.aead=this.aead_test()}else console.error("SeaSalt - Libsodium was not found")}encrypt(string,secret,box){if(!string)throw"SeaSalt.encrypt() requires a string or object to encrypt";if(!secret)secret=
this.config.secret;if(!secret)throw"SeaSalt.encrypt() could not find a password to use";if(typeof this.aead[this.config.algorithm]==="object")return this.aead[this.config.algorithm].encrypt(string,secret,box);else throw"SeaSalt.encrypt() received invalid algorithm - "+this.config.algorithm;}decrypt(string,secret,box){if(!string)throw"SeaSalt.decrypt() requires a string to decrypt";if(!secret)secret=this.config.secret;if(!secret)throw"SeaSalt.decrypt() could not find a password to use";if(typeof this.aead[this.config.algorithm]===
"object")return this.aead[this.config.algorithm].decrypt(string,secret,box);else throw"SeaSalt.decrypt() received invalid algorithm - "+this.config.algorithm;}pwhash_create(password,security,algorithm){if(!algorithm)algorithm=this.config.pwhash;if(algorithm&&Object.keys(this.pwhash).indexOf(algorithm)===-1)algorithm=this.config.pwhash;return this.pwhash[algorithm].create(password,security)}pwhash_verify(hash,password,algorithm){if(!algorithm)algorithm=this.config.pwhash;if(algorithm&&Object.keys(this.pwhash).indexOf(algorithm)===
-1)algorithm=this.config.pwhash;return this.pwhash[algorithm].verify(hash,password)}test(){let result=sodium.to_hex(sodium.crypto_generichash(64,"test"));return result==="a71079d42853dea26e453004338670a53814b78137ffbed07603a41d76a483aa9bc33b582f77d30a65e6f29a896c0411f38312e1d66e0bf16386c86a89bea572"}aead_test(){let original="test";let ciphertext=this.encrypt(original);let result=this.decrypt(ciphertext);return original===result}}class SeaSalt extends SeaSalt_Common{}
class SeaSalt_Hashing{constructor(string,salt,hash,format){this.reservedProperties=["constructor","toString"];this.validHashes=["sha256","sha512","generic","short","long"];this.validFormats=["hex","binary","base64"];if(this.validHashes.indexOf(salt)>-1){format=hash;hash=salt;salt=undefined}if(typeof string==="string"){let props=Object.getOwnPropertyNames(Object.getPrototypeOf(new SeaSalt_Hashing));for(let x=0;x<this.reservedProperties.length;x++)props.splice(props.indexOf(this.reservedProperties[x]),
1);props=JSON.parse(JSON.stringify(props));if(typeof hash==="undefined")hash="sha256";if(this.validFormats.indexOf(format)===-1)format="hex";if(props.indexOf(hash)===-1)throw"Invalid hash algorithm requested.";if(["generic","short"].indexOf(hash)>-1){this.hex=this[hash](string,salt);this.binary=sodium.from_hex(this.hex);this.base64=sodium.to_base64(this.binary)}else{this.binary=this[hash](string,salt,"binary");this.hex=sodium.to_hex(this.binary);this.base64=sodium.to_base64(this.binary)}this.format=
format;this.length=this[this.format].length}}toString(){return this.hex}sha256(string,salt,format){if(salt instanceof Uint8Array)salt=sodium.to_hex(salt);if(typeof salt!=="string")salt="";if(!format)format="hex";if(this.validFormats.indexOf(format)===-1)format="hex";let salted=string;if(salt.length>0)salted=salt+string.substr(0,Math.floor(string.length/2))+salt+string.substr(Math.floor(string.length/2),string.length)+salt;let result=sodium.crypto_hash_sha256(salted);if(format==="hex")return sodium.to_hex(result);
if(format==="base64")return sodium.to_base64(result);return result}sha512(string,salt,format){if(salt instanceof Uint8Array)salt=sodium.to_hex(salt);if(typeof salt!=="string")salt="";if(!format)format="hex";if(this.validFormats.indexOf(format)===-1)format="hex";let salted=string;if(salt.length>0)salted=salt+string.substr(0,Math.floor(string.length/2))+salt+string.substr(Math.floor(string.length/2),string.length)+salt;let result=sodium.crypto_hash_sha512(salted);if(format==="hex")return sodium.to_hex(result);
if(format==="base64")return sodium.to_base64(result);return result}generic(string,key,config){if(typeof key==="object"&&!(key instanceof Uint8Array)){config=key;key=undefined}if(typeof config!=="object")config={};if(typeof config.size!=="number")config.size=sodium.crypto_generichash_BYTES;if(config.size<sodium.crypto_generichash_BYTES&&config.force!==true)throw"Requested size is smaller than minimum ("+sodium.crypto_generichash_BYTES+") and force is not set to true";if(config.size>sodium.crypto_generichash_BYTES*
2)throw"Requested size is larger than the maximum sized allowed ("+sodium.crypto_generichash_BYTES*2+")";if(config.size<1)throw"Requested size is too small";if(typeof key==="string"||key instanceof Uint8Array)config.key=key;if(typeof config.key!=="string"&&!(config.key instanceof Uint8Array))config.key=undefined;return sodium.to_hex(sodium.crypto_generichash(config.size,string,config.key))}short(string,key){if(typeof key==="undefined")key="";if(key==="random")key=sodium.randombytes_buf(sodium.crypto_shorthash_KEYBYTES);
if(typeof key==="string"&&key.match(/^([a-fA-F0-9]{32})$/)===null)key=sodium.from_hex(this.generic(key,{size:sodium.crypto_shorthash_KEYBYTES,force:true}));if(typeof key==="string")key=sodium.from_hex(key);return sodium.to_hex(sodium.crypto_shorthash(string,key))}long(string,key){if(typeof key==="undefined")key="";if(key==="random")key=sodium.randombytes_buf(sodium.crypto_shorthash_siphashx24_KEYBYTES);if(typeof key==="string"&&key.match(/^([a-fA-F0-9]{32})$/)===null)key=sodium.from_hex(this.generic(key,
{size:sodium.crypto_shorthash_siphashx24_KEYBYTES,force:true}));if(typeof key==="string")key=sodium.from_hex(key);return sodium.to_hex(sodium.crypto_shorthash_siphashx24(string,key))}}
class SeaSalt_PWHash_Argon2{create(password,security){let opsLimit=sodium.crypto_pwhash_OPSLIMIT_INTERACTIVE;if(!security)security="normal";if(["light","normal","moderate","high"].indexOf(security)===-1)security="normal";if(security==="normal")opsLimit=opsLimit*2;else if(security==="moderate")opsLimit=opsLimit*4;else if(security==="high")opsLimit=opsLimit*6;return sodium.crypto_pwhash_str(password,opsLimit,sodium.crypto_pwhash_MEMLIMIT_INTERACTIVE)}verify(hash,password){return sodium.crypto_pwhash_str_verify(hash,
password)}derive(secret,salt,config){if(typeof salt==="object"&&!(salt instanceof Uint8Array)){config=salt;salt=undefined}if(typeof config!=="object")config={};if(typeof config.salt==="string")salt=sodium.from_hex(config.salt);if(typeof salt==="string")try{salt=sodium.from_hex(salt)}catch(e){salt=sodium.from_hex((new SeaSalt_Hashing).generic(salt,{size:sodium.crypto_pwhash_SALTBYTES,key:salt,force:true}))}if(!(salt instanceof Uint8Array))salt=sodium.randombytes_buf(sodium.crypto_pwhash_SALTBYTES);
if(typeof config.ops==="undefined")config.ops=sodium.crypto_pwhash_OPSLIMIT_SENSITIVE*2;if(typeof config.mem==="undefined")config.mem=sodium.crypto_pwhash_MEMLIMIT_INTERACTIVE;if(typeof config.alg==="undefined")config.alg=sodium.crypto_pwhash_ALG_DEFAULT;if(typeof config.size==="undefined")config.size=32;return{salt:sodium.to_hex(salt),key:sodium.to_hex(sodium.crypto_pwhash(config.size,secret,salt,config.ops,config.mem,config.alg))}}}
class SeaSalt_PWHash_SCrypt{create(password,security){let opsLimit=sodium.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE;let memLimit=sodium.crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_INTERACTIVE;if(!security)security="normal";if(["light","normal","moderate","high"].indexOf(security)===-1)security="normal";if(security==="normal")opsLimit=sodium.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE*3;else if(security==="moderate")opsLimit=(sodium.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE+
sodium.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_SENSITIVE)*.25;else if(security==="high")opsLimit=sodium.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_SENSITIVE;let result=sodium.crypto_pwhash_scryptsalsa208sha256_str(password,opsLimit,memLimit);return result}verify(hash,password){return sodium.crypto_pwhash_scryptsalsa208sha256_str_verify(hash,password)}derive(secret,salt,config){if(typeof salt==="object"&&!(salt instanceof Uint8Array)){config=salt;salt=undefined}if(typeof config!=="object")config=
{};if(typeof config.salt==="string")salt=sodium.from_hex(config.salt);if(typeof salt==="string")try{salt=sodium.from_hex(salt)}catch(e){salt=sodium.from_hex((new SeaSalt_Hashing).generic(salt,{size:sodium.crypto_pwhash_scryptsalsa208sha256_SALTBYTES,key:salt,force:true}))}if(!(salt instanceof Uint8Array))salt=sodium.randombytes_buf(sodium.crypto_pwhash_scryptsalsa208sha256_SALTBYTES);if(typeof config.ops==="undefined")config.ops=sodium.crypto_pwhash_scryptsalsa208sha256_OPSLIMIT_INTERACTIVE*10;if(typeof config.mem===
"undefined")config.mem=sodium.crypto_pwhash_scryptsalsa208sha256_MEMLIMIT_INTERACTIVE;if(typeof config.alg==="undefined")config.alg=sodium.crypto_pwhash_scryptsalsa208sha256_ALG_DEFAULT;if(typeof config.size==="undefined")config.size=32;return{salt:sodium.to_hex(salt),key:sodium.to_hex(sodium.crypto_pwhash_scryptsalsa208sha256(config.size,secret,salt,config.ops,config.mem,config.alg))}}}
class SeaSalt_AEAD_SecretBox{constructor(userPassword,secretItem,config){this.config={logger:console.log,minimumEntropy:1,minimumKeyLength:1,minimumStrength:0,key:"hash",cipher:"xchacha",salt:undefined};if(typeof userPassword==="object"){config=userPassword;userPassword=undefined;secretItem=undefined}if(typeof secretItem==="object"){config=secretItem;secretItem=undefined;if(config.keysalt||config.secret){secretItem={keysalt:config.keysalt,secret:config.secret};delete config.keysalt;delete config.secret}}if(typeof config===
"object")for(let i in config)if(config.hasOwnProperty(i))this.config[i]=config[i];this.hash=new SeaSalt_Hashing;this.tools=new SeaSalt_Tools(config);this.aead=new SeaSalt_AEAD(this.config);if(userPassword)this.box=this.create(userPassword,secretItem)}toString(){return this.box}create(userPassword,secretItem){if(this.box)return this.box;if(this.tools.passwordStrength(userPassword)<this.config.minimumStrength)throw"Supplied password does not meet the minimum strength requirements.";if(typeof secretItem===
"function")throw"Funcation are not valid secret items";if(typeof secretItem==="object"&&typeof secretItem.secret!=="string")secretItem.secret=this.aead.key();if(typeof secretItem==="undefined")secretItem=this.aead.key();secretItem=JSON.stringify(secretItem);if(typeof secretItem!=="string")throw"Supplied secret item cannot be converted to a string.";let aead=new SeaSalt_AEAD(this.config);this.box=aead.encrypt(secretItem,userPassword);let contents=aead.decrypt(this.box,userPassword);if(contents!==secretItem){this.config.logger("SeaSalt/AEAD/box_create - Failed to validate box contents");
throw"Failed to validate the box contents.";}return this.box}repackage(box,userPassword,newPassword){if(!box&&!this.box)throw"Secret box must be provided for repackaging.";if(box&&userPassword&&!newPassword){if(!this.box)throw"Secret box must be provided for repackaging.";newPassword=userPassword;userPassword=box;box=this.box}if(!box||!userPassword||!newPassword)throw"Required arguments are missing";if(this.tools.passwordStrength(newPassword)<this.config.minimumStrength)throw"Password does not meet requirements";
let contents;try{contents=JSON.parse((new SeaSalt_AEAD(this.config)).decrypt(box,userPassword))}catch(e){}if(typeof contents==="undefined")return box;this.box=this.create(newPassword,contents);return this.box}check(box,userPassword,secretItem){if(!box&&!this.box)throw"Secret box must be provided for checking.";if(box&&!userPassword){if(!this.box)throw"Secret box must be provided for repackaging.";userPassword=box;box=this.box}if(!box||!userPassword)throw"Required arguments are missing";let aead=new SeaSalt_AEAD(this.config);
if(typeof secretItem==="undefined"){let result;try{result=aead.decrypt(box,userPassword)}catch(e){return false}return result===true}if(secretItem&&typeof secretItem==="boolean")secretItem=secretItem===false?"false":"true";if(secretItem&&typeof secretItem==="number")secretItem=secretItem.toString();if(secretItem&&typeof secretItem==="object")secretItem=JSON.stringify(secretItem,null,5);if(secretItem&&typeof secretItem!=="string")return false;let contents=aead.decrypt(box,userPassword);return secretItem&&
contents===secretItem||typeof contents==="string"}}
class SeaSalt_AEAD{constructor(string,secret,box,config){if((typeof box==="object"||typeof secret==="object")&&typeof config==="undefined"){if(typeof secret==="object"){config=secret;secret=undefined;box=undefined}if(typeof box==="object"&&(!(box instanceof SeaSalt_AEAD_SecretBox)||!box.box)){config=box;box=undefined}}if(typeof string==="object"){config=string;string=undefined}this.ciphers={xchacha:{nonce_bytes:sodium.crypto_aead_xchacha20poly1305_ietf_NPUBBYTES,encrypt:sodium.crypto_aead_xchacha20poly1305_ietf_encrypt,
decrypt:sodium.crypto_aead_xchacha20poly1305_ietf_decrypt,keygen:sodium.crypto_aead_xchacha20poly1305_ietf_keygen},chacha20_ietf:{nonce_bytes:sodium.crypto_aead_chacha20poly1305_ietf_NPUBBYTES,encrypt:sodium.crypto_aead_chacha20poly1305_ietf_encrypt,decrypt:sodium.crypto_aead_chacha20poly1305_ietf_decrypt,keygen:sodium.crypto_aead_chacha20poly1305_ietf_keygen},chacha20:{nonce_bytes:sodium.crypto_aead_chacha20poly1305_NPUBBYTES,encrypt:sodium.crypto_aead_chacha20poly1305_encrypt,decrypt:sodium.crypto_aead_chacha20poly1305_decrypt,
keygen:sodium.crypto_aead_chacha20poly1305_keygen}};this.config={cache:true,cipher:"xchacha",key:"hash",logger:console.log,minimumEntropy:1,minimumKeyLength:1,minimumStrength:0,salt:undefined};this.cache={};if(typeof config==="object")for(let i in config)if(config.hasOwnProperty(i))this.config[i]=config[i];if(typeof this.config.cipher==="string"&&typeof this.ciphers[this.config.cipher]!=="object")throw"Requested cipher is not valid";this.sodium=this.ciphers[this.config.cipher];if(typeof this.config.secret===
"string"){secret=this.config.secret;delete this.config.secret}this.hash=new SeaSalt_Hashing;this.tools=new SeaSalt_Tools;if(this.config.cache===true&&typeof secret==="string"||this.config.key==="aead"){if(this.config.key==="key")this.computedkey=secret;if(this.config.key==="aead")this.computedkey=sodium.from_hex(this.key("aead",secret,this.config.salt));if(this.config.key==="argon2")this.computedkey=sodium.from_hex(this.key("argon2",secret,this.config.salt));if(!(this.computedkey instanceof Uint8Array)&&
typeof secret==="string")this.computedkey=sodium.from_hex(this.key("sha256",secret,this.config.salt));if(typeof secret!=="undefined")this.cache[(new SeaSalt_Hashing).sha256(secret,this.config.salt)]=sodium.to_hex(this.computedkey);this.salt=this.config.salt}if(typeof string==="string")this.encrypt(string,secret,box)}encrypt(string,secret,box,salt,isKey){if(typeof salt==="boolean"){isKey=salt;salt=undefined}let chash;if(typeof secret==="string"&&isKey!==true)chash=(new SeaSalt_Hashing).sha256(secret,
salt||this.config.salt);if(this.config.cache===true&&(typeof secret==="undefined"&&this.computedkey)||typeof chash==="string"&&typeof this.cache[chash]==="string"){if(typeof secret==="undefined"&&typeof chash==="string"&&typeof this.cache[chash]==="object"&&this.computedkey!==this.cache[chash])this.computedkey=this.cache[chash];secret=sodium.from_hex(sodium.to_hex(this.computedkey));isKey=true}if(!string||!secret)throw"SeaSalt_AEAD_XChaCha::encrypt requires a string or secret to encrypt";if(typeof box===
"boolean"){isKey=box;box=undefined}if(box instanceof SeaSalt_AEAD_SecretBox&&typeof box.box==="string")box=box.box;else if(box&&typeof box!=="string")throw"SecretBox is invalid";if(typeof box==="string"){let contents=this.decrypt(box,secret,undefined,salt,isKey);if(typeof contents==="string"){let object;try{object=JSON.parse(contents)}catch(e){}secret=typeof object==="object"?object.secret:contents}else throw"Failed to decrypt secret box.";}if(typeof secret==="string"&&isKey!==true&&this.tools.passwordStrength(secret)<
this.config.minimumStrength)throw"Password does not meet minimum strength requirements";let key=secret instanceof Uint8Array?secret:sodium.from_hex(isKey===true||this.config.key==="key"?secret:this.key(this.config.key,secret,salt||this.config.salt));if(this.config.cache===true&&typeof chash==="string"&&!this.cache[chash])this.cache[chash]=sodium.to_hex(key);let nonce=sodium.randombytes_buf(this.sodium.nonce_bytes);let ciphertext=this.sodium.encrypt(string,"","",nonce,key);sodium.memzero(key);this.ciphertext=
sodium.to_hex(nonce)+sodium.to_hex(ciphertext);this.box=box;return this.ciphertext}decrypt(string,secret,box,salt,isKey){if(typeof salt==="boolean"){isKey=salt;salt=undefined}let chash;if(typeof secret==="string"&&isKey!==true)chash=(new SeaSalt_Hashing).sha256(secret,salt||this.config.salt);if(typeof secret==="undefined"&&typeof chash!=="string"&&Object.keys(this.cache).length===1){secret=Object.values(this.cache)[0];isKey=true}if(typeof secret==="undefined"&&this.config.cache===true&&(this.computedkey||
typeof chash==="string"&&typeof this.cache[chash]==="string")){if(typeof secret==="undefined"&&typeof chash==="string"&&typeof this.cache[chash]==="string"&&this.computedkey!==this.cache[chash])this.computedkey=this.cache[chash];console.log(chash,this.computedkey);secret=sodium.from_hex(sodium.to_hex(this.computedkey));isKey=true}if(!string)throw"Requires a string to decrypt";if(!secret)throw"Requires a key to decrypt";if(typeof box==="boolean"){isKey=box;box=undefined}if(box instanceof SeaSalt_AEAD_SecretBox&&
typeof box.box==="string")box=box.box;else if(box&&typeof box!=="string")throw"Secretbox is invalid";if(typeof box==="string"){let contents=this.decrypt(box,secret,undefined,salt,isKey);if(typeof contents==="string"){let object;try{object=JSON.parse(contents)}catch(e){}secret=typeof object==="object"?object.secret:contents}else throw"Failed to decrypt secret box.";}let nonce;let ciphertext;try{nonce=sodium.from_hex(string.substr(0,this.sodium.nonce_bytes*2));ciphertext=sodium.from_hex(string.substr(this.sodium.nonce_bytes*
2,string.length))}catch(e){return undefined}let key=secret instanceof Uint8Array?secret:sodium.from_hex(isKey===true||this.config.key==="key"?secret:this.key(this.config.key,secret,salt||this.config.salt));if(this.config.cache===true&&typeof chash==="string"&&!this.cache[chash])this.cache[chash]=sodium.to_hex(key);let result="";try{result=this.sodium.decrypt("",ciphertext,"",nonce,key)}catch(e){}sodium.memzero(key);return result?sodium.to_string(result):undefined}key(type,secret,salt){if(!secret||
type==="aead")return sodium.to_hex(this.sodium.keygen());if(type==="argon2"){if(typeof secret!=="string"||secret.length===0)throw"Argon2 secret not provided";return(new SeaSalt_PWHash_Argon2).derive(secret,salt).key}if(type==="scrypt"){if(typeof secret!=="string"||secret.length===0)throw"SCrypt secret not provided";return(new SeaSalt_PWHash_SCrypt).derive(secret,salt).key}return this.hash.sha256(secret,salt)}toJSON(){let data={box:this.box,ciphertext:this.ciphertext};return JSON.stringify(data,null,
5)}}
class SeaSalt_AEAD_XChaCha{constructor(string,secret,box,config){if((typeof box==="object"||typeof secret==="object")&&typeof config==="undefined"){if(typeof secret==="object"){config=secret;secret=undefined;box=undefined}if(typeof box==="object"&&(!(box instanceof SeaSalt_AEAD_SecretBox)||!box.box)){config=box;box=undefined}}if(typeof string==="object"){config=string;string=undefined}if(typeof config!=="object")config={};config.cipher="xchacha";return new SeaSalt_AEAD(string,secret,box,config)}}
class SeaSalt_AEAD_ChaCha20_IETF{constructor(string,secret,box,config){if((typeof box==="object"||typeof secret==="object")&&typeof config==="undefined"){if(typeof secret==="object"){config=secret;secret=undefined;box=undefined}if(typeof box==="object"&&(!(box instanceof SeaSalt_AEAD_SecretBox)||!box.box)){config=box;box=undefined}}if(typeof string==="object"){config=string;string=undefined}if(typeof config!=="object")config={};config.cipher="chacha20_ietf";return new SeaSalt_AEAD(string,secret,box,
config)}}
class SeaSalt_AEAD_ChaCha20{constructor(string,secret,box,config){if((typeof box==="object"||typeof secret==="object")&&typeof config==="undefined"){if(typeof secret==="object"){config=secret;secret=undefined;box=undefined}if(typeof box==="object"&&(!(box instanceof SeaSalt_AEAD_SecretBox)||!box.box)){config=box;box=undefined}}if(typeof string==="object"){config=string;string=undefined}if(typeof config!=="object")config={};config.cipher="chacha20";return new SeaSalt_AEAD(string,secret,box,config)}}
class SeaSalt_Tools{constructor(config){let self=this;this.config={minimumEntropy:6,minimumKeyLength:6,minimumStrength:1};if(typeof config==="object")Object.keys(config).filter(function(key){if(typeof self.config[key]!=="undefined")self.config[key]=config[key]});if(typeof this.config.logger==="undefined")this.config.logger=console.log}randomString(length,alpha,caps,numbers,symbols){if(!length)length=32;function find_pool(char){let pool;try{pool=Object.keys(config.pools).filter(function(key){if(config.pools[key].indexOf(char)>
-1)return true})[0]}catch(e){return}return pool}let config={alpha:typeof alpha==="boolean"?alpha:true,caps:typeof caps==="boolean"?caps:true,debug:false,length:typeof length==="number"?length:32,loose:false,max:{},maxLoops:65536,min:{},numbers:typeof numbers==="boolean"?numbers:true,pools:{alpha:"abcdefghijklmnopqrstuvwxyz",caps:"ABCDEFGHIJKLMNOPQRSTUVWXYZ",numbers:"0123456789",symbols:"[];',./<>?:\"{}\\|!@#$%^&*()-=_+`~"},shuffle:32,statsSamples:6,symbols:typeof symbols==="boolean"?symbols:true};
if(typeof length==="object")Object.keys(length).filter(function(key){if(key==="pools"){Object.keys(length.pools).filter(function(pool){config.pools[pool]=length.pools[pool]});return}if(typeof config[key]!=="undefined")config[key]=length[key]});if(config.maxLoops===-1)config.maxLoops=6.3072E27;Object.keys(config.pools).filter(function(pool){if(config[pool]===true&&typeof config.max[pool]!=="number")config.max[pool]=config.length;if(config[pool]===false)config.max[pool]=0});let min=0;if(typeof config.min===
"object")Object.keys(config.min).filter(function(pool){if(typeof config.min[pool]!=="number")throw new Error("Invalid pool value in minimum");if(config.min[pool]<1&&config.min[pool]>0){min+=config.min[pool];config.min[pool]=Math.round(config.length*config.min[pool])}else min+=Number((config.min[pool]/config.length).toFixed(2))});if(min>1||min<0)throw new Error("Total minimums is out of bounds");let max=0;if(typeof config.max==="object")Object.keys(config.max).filter(function(pool){if(typeof config.max[pool]!==
"number")throw new Error("Invalid pool value in maximum");if(config.max[pool]<1&&config.max[pool]>0){max+=config.max[pool];config.max[pool]=Math.round(config.length*config.max[pool])}else max+=Number((config.max[pool]/config.length).toFixed(2))});if(max===0)max=1;if(max<1){if(config.loose!==true)throw new Error("Total maximums does not meet string length");config.length=Math.round(config.length*max)}if(min>max)new Error("Total minimums are greater than maximums");if(typeof config.min==="object"&&
typeof config.max==="object")Object.keys(config.min).filter(function(pool){if(typeof config.max[pool]==="number"&&config.min[pool]>config.max[pool])throw new Error("Minimum limit cannot exceed maximum limit for "+pool);});config.pool="";if(config.alpha===true)config.pool=config.pool.concat(config.pools.alpha);if(config.caps===true)config.pool=config.pool.concat(config.pools.caps);if(config.numbers===true)config.pool=config.pool.concat(config.pools.numbers);if(config.symbols===true)config.pool=config.pool.concat(config.pools.symbols);
if(config.pool.length===0)throw new Error("No character pool has been provided");let count={};Object.keys(config.pools).filter(function(key){count[key]=0});if(config.statsSamples<2){console.warn("Provided configuration key `statsSamples` was below minimum value of `2` and has been adjusted automatically");config.statsSamples=2}let stats={loop1:{it:[],avg:0,count:0},loop2:{it:[],avg:0,count:0,conflicts:0}};let string="";let it=0;while(string.length<config.length){let start=Date.now();if(stats.loop1.it.length>
0){let diff=start-stats.loop1.it[stats.loop1.it.length-1];stats.loop1.avg=stats.loop1.it.length===1?diff:stats.loop1.avg+diff;if(stats.loop1.it.length===config.statsSamples)stats.loop1.it.shift()}stats.loop1.it.push(start);stats.loop1.count++;it++;if(it>config.length*2&&it>config.maxLoops)console.warn("Encountered suspected infinite loop in string generation (loop 1)");config.pool=config.pool.split("").sort(function(){return sodium.randombytes_uniform(2)}).join("");let char=config.pool.charAt(sodium.randombytes_uniform(config.pool.length));
let origin=find_pool(char);if(typeof config.max[origin]==="number"&&count[origin]>=config.max[origin])continue;count[origin]++;string+=char;let lock=[];if(string.length===config.length)Object.keys(config.min).filter(function(min){if(typeof config.min[min]!=="number"||config.min[min]===0)return;let count=0;string.split("").filter(function(char){if(min===find_pool(char))count++});if(count>=config.min[min])return;while(config.min[min]-count>0){let start=Date.now();if(stats.loop2.it.length>0){let diff=
start-stats.loop2.it[stats.loop2.it.length-1];stats.loop2.avg=stats.loop2.it.length===1?diff:stats.loop2.avg+diff;if(stats.loop2.it.length===config.statsSamples)stats.loop2.it.shift()}stats.loop2.it.push(start);stats.loop2.count++;it++;if(it>config.length*2&&it>config.maxLoops)throw new Error("Encountered infinite loop in string generation (loop 2)");let index=sodium.randombytes_uniform(string.length);let pool=find_pool(string.charAt(index));if(pool===min||lock.indexOf(pool)>-1){stats.loop2.conflicts++;
continue}lock.push(min);let newchar=config.pools[min].charAt(sodium.randombytes_uniform(config.pools[min].length));let splode=string.split("");splode[index]=newchar;string=splode.join("");count++}})}for(let i=0;i<config.shuffle;i++)string=string.split("").sort(function(){return sodium.randombytes_uniform(2)}).join("");if(stats.loop1.count>0)stats.loop1.avg=stats.loop1.avg/stats.loop1.count;if(stats.loop2.count>0)stats.loop2.avg=stats.loop2.avg/stats.loop2.count;if(config.debug===true)return{result:string,
config:config,stats:stats};return string}passwordStrength(password){let strength=0;let cat=0;let matches={};if(matches.alpha=password.match(/[a-z]/g))strength++;if(matches.caps=password.match(/[A-Z]/g))strength++;if(matches.numeric=password.match(/[0-9]/g))strength++;if(matches.symbol=password.match(/[-!$%^&*()_+|~=`{}\[\]:#";'@<>?,.\/]/g))strength++;cat=strength;let chars=[];for(let i in matches)if(matches.hasOwnProperty(i))if(typeof matches[i]==="object"&&matches[i]!==null&&matches[i].length)for(let x=
0;x<matches[i].length;x++)if(chars.indexOf(matches[i][x].toLowerCase())===-1)chars.push(matches[i][x].toLowerCase());if(chars.length>=this.config.minimumEntropy)strength=strength++;if(chars.length<this.config.minimumEntropy)strength=strength-3;if(strength===1&&password.length>=this.config.minimumKeyLength*2)strength++;if(password.length<this.config.minimumKeyLength+4)strength--;if(cat===1)strength--;if(password.length<this.config.minimumKeyLength)strength=0;if(strength<0)strength=0;if(strength>4)strength=
4;return strength}}
class SeaSalt_Keychain{constructor(sig,password,config){if(typeof password==="object"){config=password;password=undefined}if(typeof sig==="object"){config=sig;sig=undefined;password=undefined}let self=this;this.test=[];this.config={encCipher:"xchacha",encKey:"aead",debug:false,genericKeyLength:16,hash:"sha256",keysaltLength:24,maxRecoveryAge:undefined,maxRecoveryPoints:5,minimumEntropy:6,minimumKeyLength:6,minimumStrength:1,mode:0,readonly:false,recoveryTokenCount:2,recoveryTokenLength:15,saltLength:16,
signatureLength:16,storage:{checksums:false,enabled:true,includeMeta:false,lock:true,lockMode:"write",lockTtl:144E5,prefix:"seasalt:keychain:",read:function(key){return localStorage.getItem(key)},write:function(key,value){return localStorage.setItem(key,value)},delete:function(key){return localStorage.removeItem(key)},list:function(){return Object.keys(localStorage)}},log:undefined};if(typeof sig==="string"&&typeof password==="string"){this.config.sig=sig;this.config.password=password;sig=undefined;
password=undefined}if(typeof config==="object")Object.keys(config).filter(function(key){if(typeof config[key]!=="object")self.config[key]=config[key];if(typeof config[key]==="object")Object.keys(config[key]).filter(function(k2){self.config[key][k2]=config[key][k2]})});if(typeof this.config.storage.prefix!=="string")this.error("No storage prefix has been specified");if(typeof this.config.log!=="function")this.config.log=function(){if(this.config.debug===true){if(typeof arguments[0]==="string")console.log.apply(null,
arguments);if(typeof arguments[0]==="object")console.error(null,arguments)}};let regex=new RegExp("^"+this.config.storage.prefix+"([a-zA-Z0-9]*?):keyconf$");this.keys={};this.config.storage.list().filter(function(key){let matches=key.match(regex);if(matches===null)return;let data;try{data=JSON.parse(self.config.storage.read(key))}catch(e){return}self.keys[matches[1]]=data});this.aead=this.gen_aead();this.tools=new SeaSalt_Tools(config);this.history={};this.active=undefined;this.keysalt="Q~n@nJ0(TDAtm-|s";
this.runtimeId=(new SeaSalt_Hashing).short(Date.now().toString());this.ready=true;this.log("SeaSalt/Keychain initialized successfully");if(this.config.sig&&this.config.password){try{this.open(this.config.sig,this.config.password)}catch(e){delete this.config.sig;delete this.config.password;this.error("SeaSalt/Keychain failed to open key with error: "+e)}delete this.config.sig;delete this.config.password;return}if(sig||this.config.password)this.scan(sig||this.config.password)}gen_aead(config){if(typeof config===
"string"){if(typeof this.keys[config]==="undefined")this.error("Invalid key signature provided");config={key:this.keys[config].encKey,salt:this.keys[config].encSalt,cipher:this.keys[config].encCipher}}return new SeaSalt_AEAD(typeof config==="object"?config:this.keys[this.active]?{key:this.keys[this.active].encKey,salt:this.keys[this.active].encSalt,cipher:this.keys[this.active].encCipher}:undefined)}gen_secretbox(config){if(typeof config==="string"){if(typeof this.keys[config]==="undefined")this.error("Invalid key signature provided");
config={key:this.keys[config].encKey,salt:this.keys[config].encSalt,cipher:this.keys[config].encCipher}}return new SeaSalt_AEAD_SecretBox(typeof config==="object"?config:{key:this.active&&this.keys[this.active].encKey||this.config.encKey,salt:this.active&&this.keys[this.active].encSalt||this.config.encSalt,cipher:this.active&&this.keys[this.active].encCipher||this.config.encCipher})}error(message){throw new Error(message);}hash(string,salt,hash){if(typeof hash==="string"&&["sha256","sha512","generic",
"long","short"].indexOf(hash.toLowerCase())===-1)hash=this.config.hash;if(typeof hash==="string"&&["generic","long","short"].indexOf(hash.toLowerCase())===-1)return(new SeaSalt_Hashing(string,salt,hash||this.config.hash)).toString();return(new SeaSalt_Hashing((salt||"")+string+(salt||""),hash||this.config.hash)).toString()}key(key){if(this.ready!==true||typeof this.keys[this.active]!=="object")this.error("Keychain state not ready");let enckey;if(this.keys[this.active].mode===0)enckey=this.hash(key,
this.keysalt,"sha256");if(this.keys[this.active].mode===1)enckey=this.hash(key,this.keysalt,"sha512");if(this.keys[this.active].mode===2)enckey=(new SeaSalt_Hashing).generic(key,this.keysalt,{size:this.keys[this.active].genericKeyLength||this.config.genericKeyLength,force:true});if(this.keys[this.active].mode===100)enckey=key;if(typeof enckey!=="string")enckey=this.hash(key,this.keysalt);return this.config.storage.prefix+this.active+":storage:"+this.keys[this.active].format+":"+this.keys[this.active].mode+
":"+enckey}keyconf(config){let object={box:"",encCipher:this.config.encCipher,encKey:this.config.encKey,encSalt:this.config.encSalt,format:0,genericKeyLength:this.config.genericKeyLength,history:[],mode:this.config.mode,name:"",recovery:{},salt:""};if(typeof config!=="object")config={};Object.keys(config).filter(function(key){if(typeof object[key]==="undefined")return;object[key]=config[key]});if(typeof object.encCipher==="undefined")object.encCipher="xchacha";if(object.mode!==2)delete object.genericKeyLength;
return object}listkeys(){return Object.keys(this.keys)}lock(state,force){if(this.ready!==true||typeof this.keys[this.active]!=="object")this.error("Keychain state not ready");if(force!==true&&this.config.readonly===true)this.error("Keychain is in read-only mode");if(this.config.storage.enabled!==true)this.error("LocalStorage is not enabled");let lockfile;let lockkey=this.config.storage.prefix+this.active+":lock";try{lockfile=JSON.parse(this.config.storage.read(lockkey))}catch(e){}if(force===true||
lockfile===null||typeof lockfile!=="object"||!lockfile.runtimeId||lockfile.runtimeId===this.runtimeId||Date.now()-lockfile.date>this.config.storage.lockTtl){if(state===true)lockfile={date:Date.now(),runtimeId:this.runtimeId};if(state===false)lockfile={};try{this.config.storage.write(lockkey,JSON.stringify(lockfile))}catch(e){this.log("Encountered storage API error: "+e);return false}if(state===true&&force===true)this.config.readonly=false;return true}this.log("Encountered active lock file: "+JSON.stringify(lockfile));
return false}log(arg){this.config.log.apply(this,arguments)}save(sig,force){if(typeof sig==="boolean"){force=sig;sig=undefined}if(this.ready!==true)this.error("Keychain state not ready");if(this.config.readonly===true&&force!==true)this.error("Keychain is in read-only mode");if(this.config.storage.enabled!==true)this.error("LocalStorage is not enabled");if(typeof this.keys[sig||this.active]!=="object"&&force!==true)this.error("Keychain state not ready");try{this.config.storage.write(this.config.storage.prefix+
(sig||this.active)+":keyconf",JSON.stringify(this.keys[sig||this.active]))}catch(e){this.log("SeaSalt/Keychain failed to write keyconf to localStorage: "+e);return false}this.log("SeaSalt/Keychain successfully saved "+(sig||this.active)+" keyconf");return true}check(sig,userPassword){return this.open(sig,userPassword,true)}close(){if(this.config.storage.lock===true&&this.config.storage.lockMode==="session")this.lock(false);this.active=undefined;this.passphrase=undefined;this.keysalt=undefined;return true}create(userPassword,
config){if(this.ready!==true)this.error("Keychain state not ready");if(this.config.readonly===true)this.error("Keychain is in read-only mode");if(this.tools.passwordStrength(userPassword)<this.config.minimumStrength)this.error("Password does not meet minimum strength requirements");if(typeof config!=="object")config={};if(typeof config.encKey!=="string")config.encKey="aead";if(typeof config.encCipher!=="string")config.encCipher="xchacha";let mode=config.mode;let name=config.name||(new Date).toLocaleString();
let sig=(new SeaSalt_Tools).randomString(this.config.signatureLength,true,true,true,false);let salt=(new SeaSalt_Tools).randomString(this.config.saltLength);let keysalt=(new SeaSalt_Tools).randomString(this.config.keysaltLength);let passphrase=this.hash(this.hash(userPassword),salt);this.log("SeaSalt/Keychain - generating encryption key: "+(config.encKey||this.config.encKey)+" "+(config.encCipher||this.config.encCipher));if(["scrypt","argon2"].indexOf(config.encKey)>-1||typeof config==="undefined"&&
["scrypt","argon2"].indexOf(this.config.encKey)>-1)this.log("+ "+(config.encKey||this.config.encKey)+" may take awhile on slower machines");let secretbox=new SeaSalt_AEAD_SecretBox(passphrase,{key:config.encKey||this.config.encKey,salt:config.encSalt,cipher:config.encCipher||this.config.encCipher,keysalt:keysalt,secret:(new SeaSalt_AEAD({key:config.encKey,salt:config.encSalt,cipher:config.encCipher})).key(config.encKey,userPassword,config.encSalt)});if(config.encKey==="aead")config.encKey="key";this.keys[sig]=
this.keyconf({mode:[0,1,2,100].indexOf(mode)>-1?mode:this.config.mode,box:secretbox.box,name:name,salt:salt,encKey:config.encKey||this.config.encKey,encSalt:config.encSalt||undefined,encCipher:config.encCipher||this.config.encCipher,genericKeyLength:config.genericKeyLength||undefined});if(!this.active){this.active=sig;this.passphrase=passphrase;this.keysalt=keysalt}let codes={};for(let i=0;i<this.config.recoveryTokenCount;i++){let data=this.create_recovery();this.keys[sig].recovery[this.hash(data.code)]=
data.token;codes[data.code]=data.token}if(this.save(sig)===true)return{sig:sig,codes:codes};return false}export_key(sig,raw){if(this.ready!==true||sig!==true&&this.listkeys().indexOf(sig||this.active)===-1)this.error("Keychain state not ready");if(raw===true)return sig===true?this.keys:this.keys[sig||this.active];return JSON.stringify(sig===true?this.keys:this.keys[sig||this.active],null,5)}import_key(data,sig,confirm,force){if(this.ready!==true)this.error("Keychain state not ready");if(this.config.readonly===
true)this.error("Keychain is in read-only mode");if(typeof sig==="string"&&confirm!==true)this.error("You must confirm requests that overwrite existing key configurations or use custom signatures");if(typeof sig==="string"&&!this.keys[sig]&&force!==true)this.error("Key signature does not exist");if(typeof sig!=="string")sig=(new SeaSalt_Tools).randomString(this.config.signatureLength,true,true,true,false);if(typeof data==="string")try{data=JSON.parse(data)}catch(e){}if(typeof data!=="object")this.error("Invalid key configuration provided");
let keyconf;try{keyconf=this.keyconf(data)}catch(e){this.error("Error while processing keyconf: "+e)}if(typeof keyconf!=="object")this.error("Final key configuration was invalid");this.keys[sig]=keyconf;return{sig:sig,save:this.save(sig,true)}}modify(sig,config,confirm){if(typeof sig==="object"){confirm=config;config=sig;sig=undefined}if(this.ready!==true||sig!==true&&this.listkeys().indexOf(sig||this.active)===-1)this.error("Keychain state not ready");if(this.config.readonly===true)this.error("Keychain is in read-only mode");
if(typeof config!=="object"||Object.keys(config).length===0)this.error("Invalid user configuration provided");let restricted=["box","salt","mode","genericKeyLength","encCipher","encSalt","encKey"];let forbidden=["recovery","history","format"];let self=this;let keyconf=this.keyconf();Object.keys(config).filter(function(key){if(typeof keyconf[key]==="undefined")return;if(restricted.indexOf(key)>-1&&confirm!==true)self.error("You must explicitly confirm calls that use restricted config keys. Offending key: "+
key);if(forbidden.indexOf(key)>-1)self.error("You are not allowed to modify key: "+key);if(key==="mode"&&[0,1,2,100].indexOf(config[key])===-1)self.error("Mode can only be values 0, 1, or 2")});Object.keys(config).filter(function(key){self.keys[sig||self.active][key]=config[key]});this.log("SeaSalt/Keychain modified key signature "+(sig||this.active)+" keys: "+Object.keys(config).join(", "));return this.save(sig)}open(sig,userPassword,check){if(!userPassword){userPassword=sig;let keys=this.listkeys();
sig=keys.length===1?keys[0]:undefined}if(this.ready!==true)this.error("Keychain state not ready");if(typeof this.keys[sig]!=="object")sig=this.find_signature(sig.replace("*",""));let passphrase=this.hash(this.hash(userPassword),this.keys[sig].salt);let encrypted;let aead=this.gen_aead({key:this.keys[sig].encKey,salt:this.keys[sig].encSalt,cipher:this.keys[sig].encCipher});try{encrypted=aead.encrypt("testing",passphrase,this.keys[sig].box);if(aead.decrypt(encrypted,passphrase,this.keys[sig].box)!==
"testing")return false}catch(e){return false}if(check===true)return true;this.active=sig;this.passphrase=passphrase;this.keysalt=this.get_keysalt({key:this.keys[sig].encKey,salt:this.keys[sig].encSalt,cipher:this.keys[sig].encCipher});if(this.config.storage.lock===true&&this.config.storage.lockMode==="session"&&this.lock(true)===false)this.config.readonly=true;this.log("SeaSalt/Keychain opened key with signature: "+sig);return true}store_history(sig,skipSave){if(this.ready!==true||this.listkeys().indexOf(sig||
this.active)===-1)this.error("Keychain state not ready");if(this.config.readonly===true)this.error("Keychain is in read-only mode");if(this.keys[sig||this.active].history.indexOf(this.keys[sig||this.active].box)>-1)return true;this.keys[sig||this.active].history.push(this.keys[sig||this.active].box);return skipSave===true?true:this.save(sig)}update(newPassword){if(this.ready!==true||typeof this.keys[this.active]!=="object")this.error("Keychain state not ready");if(this.config.readonly===true)this.error("Keychain is in read-only mode");
if(this.tools.passwordStrength(newPassword)<this.config.minimumStrength)this.error("Password does not meet minimum strength requirements");if(typeof newPassword==="string"&&typeof this.keys[this.active]==="object")this.store_history();let passphrase=typeof newPassword==="string"?this.hash(this.hash(newPassword),this.keys[this.active].salt):undefined;let newbox=this.gen_secretbox().repackage(this.keys[this.active].box,this.passphrase,passphrase||this.passphrase);if(newbox===this.keys[this.active].box)return false;
this.keys[this.active].box=newbox;if(passphrase)this.passphrase=passphrase;return this.save()}create_recovery(sig,userPassword,box){if(typeof sig==="string"&&typeof userPassword!=="string"){box=sig;sig=undefined;userPassword=undefined}if(typeof sig==="string"&&typeof userPassword==="string"){this.close();this.open(sig,userPassword)}if(this.ready!==true||typeof this.keys[this.active]!=="object")this.error("Keychain state not ready");if(this.config.readonly===true)this.error("Keychain is in read-only mode");
if(!box&&(typeof this.keys[this.active]!=="object"||typeof this.passphrase!=="string"))this.error("Invalid arguments");let code=this.tools.randomString({length:this.config.recoveryTokenLength,pools:{symbols:"#-+=*"},max:{symbols:4},min:{symbols:3}});let token=this.gen_secretbox().repackage(box||this.keys[this.active].box,this.passphrase,this.hash(this.hash(code),this.keys[this.active].salt));return{code:code,token:token}}find_recovery(sig,code,boxes){if(typeof this.keys[sig]!=="object")sig=this.find_signature(sig.replace("*",
""));if(typeof boxes==="undefined")boxes=Object.values(this.keys[sig].recovery);if(typeof boxes==="string")boxes=[boxes];if(!Array.isArray(boxes))return[];let self=this;boxes=boxes.filter(function(box){let encrypted;let aead=self.gen_aead(sig);try{encrypted=aead.encrypt("testing",self.hash(self.hash(code),self.keys[sig].salt),box)}catch(e){}if(!encrypted)return false;let decrypted;try{decrypted=aead.decrypt(encrypted,self.hash(self.hash(code),self.keys[sig].salt),box)}catch(e){}return decrypted===
"testing"});return boxes}find_signature(string){let multi=false;if(string.match(/^.*?\*$/)!==null)multi=true;string=string.replace("*","");let sigmatches=[];this.listkeys().filter(function(key){if(key.match(new RegExp("^"+string+".*$","i"))!==null)sigmatches.push(key)});if(sigmatches.length===0)this.error("Invalid signature provided");if(sigmatches.length>1&&multi===false)this.error("Matched multiple signatures: "+sigmatches.join(", "));if(sigmatches.length>1||multi===true)return sigmatches;return sigmatches[0]}restore_recovery(sig,
code,newPassword,boxes){if(typeof this.keys[sig]!=="object")sig=this.find_signature(sig.replace("*",""));if(this.ready!==true)this.error("Keychain state not ready");if(this.config.readonly===true)this.error("Keychain is in read-only mode");if(this.listkeys().indexOf(sig)===-1)this.error("Invalid signature");if(typeof newPassword!=="string")this.error("Supplied new password is invalid");if(typeof boxes==="string")boxes=[boxes];if(!Array.isArray(boxes))boxes=this.find_recovery(sig,code);if(!Array.isArray(boxes)||
boxes.length===0)this.error("Supplied box is not valid");if(this.tools.passwordStrength(newPassword)<this.config.minimumStrength)this.error("Password does not meet minimum strength requirements");let self=this;let passphrase=this.hash(this.hash(newPassword),this.keys[sig].salt);let codephrase=this.hash(this.hash(code),this.keys[sig].salt);let secretbox;boxes.filter(function(box){if(typeof secretbox==="string")return;try{secretbox=self.gen_secretbox({key:self.keys[sig].encKey||self.config.encKey,salt:self.keys[sig].encSalt||
self.config.encSalt,cipher:self.keys[sig].encCipher||self.config.encCipher,passphrase:codephrase}).repackage(box,codephrase,passphrase)}catch(e){}});if(typeof secretbox!=="string")return false;this.active=sig;this.passphrase=passphrase;this.ready=true;this.store_history(sig,true);this.keys[sig].box=secretbox;this.keysalt=this.get_keysalt();return this.save(sig)}get_keysalt(config){if(this.ready!==true||typeof this.keys[this.active]!=="object")this.error("Keychain state not ready or invalid signature provided");
let jsdoc=this.gen_aead(config).decrypt(this.keys[this.active].box,config&&config.passphrase||this.passphrase);try{jsdoc=JSON.parse(jsdoc)}catch(e){}if(typeof jsdoc==="object"&&jsdoc.keysalt)return jsdoc.keysalt;this.error("Failed to locate keysalt")}decrypt(ciphertext){if(this.ready!==true||typeof this.keys[this.active]!=="object")this.error("Keychain state not ready");return this.gen_aead().decrypt(ciphertext,this.passphrase,this.keys[this.active].box)}encrypt(string){if(this.ready!==true||typeof this.keys[this.active]!==
"object")this.error("Keychain state not ready");return this.gen_aead().encrypt(string,this.passphrase,this.keys[this.active].box)}read(key,meta){if(this.ready!==true||typeof this.keys[this.active]!=="object")this.error("Keychain state not ready");if(this.config.storage.enabled!==true){this.log("SeaSalt/Keychain is bypassing a read request because localStorage is turned off");return}if(typeof meta!=="boolean")meta=this.config.storage.includeMeta===true?this.config.storage.includeMeta:false;let ciphertext;
try{ciphertext=this.config.storage.read(this.key(key))}catch(e){}if(!ciphertext)return;let json=this.decrypt(ciphertext);let data;try{data=JSON.parse(json)}catch(e){}if(typeof data!=="object")data={};return meta===true?data:data.data}read_meta(key,name){if(this.ready!==true||typeof this.keys[this.active]!=="object")this.error("Keychain state not ready");if(typeof name!=="string")name="*";let data;let regex=new RegExp("^"+this.config.storage.prefix+this.active+":storage:.*$");if(key.match(regex)===
null)key=this.key(key);try{data=JSON.parse(this.decrypt(this.config.storage.read(key)))}catch(e){}if(typeof data==="object"&&data.meta&&(["*","all"].indexOf(name)>-1||data.meta[name]))return["*","all"].indexOf(name)>-1?data.meta:data.meta[name];return false}write(key,value,meta,force){if(typeof meta==="boolean"){force=meta;meta=undefined}if(this.ready!==true||typeof this.keys[this.active]!=="object")this.error("Keychain state not ready");if(this.config.readonly===true&&force!==true)this.error("Keychain is in read-only mode");
if(this.config.storage.enabled!==true&&force!==true){this.log("SeaSalt/Keychain is bypassing a write request because localStorage is turned off");return false}if(typeof key!=="string"||typeof value!=="string")this.error("Arguments not valid");if(typeof meta!=="object")meta={};if(this.config.storage.lock===true&&this.config.storage.lock==="write")this.lock(true);if(this.config.storage.checksums===true)meta.checksum={sha256:(new SeaSalt_Hashing(value,"sha256")).hex,sha512:(new SeaSalt_Hashing(value,
"sha512")).hex};meta.key=key;meta.size=value.length;if(!meta.filetype)meta.filetype="text/plain";meta.date=new Date;let data={meta:meta,data:value};let ciphertext=this.encrypt(JSON.stringify(data));if(typeof ciphertext!=="string"){if(this.config.storage.lock===true&&this.config.storage.lock==="write")this.lock(false);return false}key=this.key(key);try{this.config.storage.write(key,ciphertext)}catch(e){if(this.config.storage.lock===true&&this.config.storage.lock==="write")this.lock(false);return false}if(this.config.storage.lock===
true&&this.config.storage.lock==="write")this.lock(false);return key}clean(config,scan){if(this.ready!==true)this.error("Keychain state not ready");if(this.config.readonly===true)this.error("Keychain is in read-only mode");if(this.config.storage.enabled===false)this.error("Clean requires that local storage be enabled.");if(config==="all")config=["mode","history","storage"];if(typeof config==="string")config=[config];if(typeof config==="undefined")config=[];if(!Array.isArray(config))this.error("Invalid configuration provided");
if(config.length===0)this.error("Your configuration is empty");let self=this;let cleaned={storage:[],mode:[],history:[]};if(config.indexOf("storage")>-1||config.indexOf("mode")>-1)this.config.storage.list().filter(function(key){let regex=new RegExp("^"+self.config.storage.prefix+"([a-zA-Z0-9]*):storage:[0-9]*?:([0-9]*?):.*$");let matches=key.match(regex);if(matches===null)return;if(config.indexOf("storage")>-1&&self.listkeys().indexOf(matches[1])===-1){cleaned.storage.push(key);if(scan!==true)self.config.storage.delete(key)}if(config.indexOf("mode")>
-1&&self.listkeys().indexOf(matches[1])>-1&&self.keys[matches[1]].mode.toString()!==matches[2]){cleaned.mode.push(key);if(scan!==true)self.config.storage.delete(key)}});if(config.indexOf("history")>-1)Object.keys(this.history).filter(function(key){if(self.listkeys().indexOf(key)>-1)return;cleaned.history.push(key);if(scan!==true)delete self.history[key]});return cleaned}destroy(sigs,history,purge){if(typeof sigs==="boolean"){purge=history;history=sigs;sigs=undefined}if(this.ready!==true)this.error("Keychain state not ready");
if(this.config.readonly===true)self.error("Keychain is in read-only mode");if(typeof sigs==="string"&&typeof this.keys[sigs]!=="object")sigs=this.find_signature(sigs);if(typeof sigs==="string")sigs=[sigs];if(!Array.isArray(sigs))this.error("Invalid signatures provided");let self=this;sigs.filter(function(sig){if(self.listkeys().indexOf(sig||self.active)===-1)throw"Signature "+sig+" does not exist";if(history!==true)self.history[sig||self.active]=self.keys[sig||self.active];delete self.keys[sig||self.active];
self.config.storage.delete(self.config.storage.prefix+(sig||self.active)+":keyconf");if(purge===true)self.purge(sig||self.active,false,true);if(sig===undefined||sig===self.active)self.close()});return true}purge(sig,all,confirm,reverse,history){if(this.ready!==true)this.error("Keychain state not ready");if(this.config.readonly===true)this.error("Keychain is in read-only mode");if(this.config.storage.enabled!==true){this.log("SeaSalt/Keychain is bypassing a purge request because localStorage is turned off");
return}if(this.listkeys().indexOf(sig)===-1&&all!==true)this.error("Signature does not exist");if(typeof all!=="boolean")this.error("Invalid arguments");if(confirm!==true)this.error("You must confirm this action in the third argument");let self=this;let keys=this.config.storage.list().filter(function(key){if(reverse===true)return key.indexOf(self.config.storage.prefix)>-1&&key.indexOf("keyring")===-1&&key.indexOf(":"+sig+":")===-1;else return key.indexOf(self.config.storage.prefix)>-1&&key.indexOf(":"+
sig+":")>-1});let sigs=[];keys.filter(function(key){self.config.storage.delete(key);let regex=new RegExp("^"+self.config.storage.prefix+"([a-zA-Z0-9]*):([a-z]*):[0-9]*?:[0-9]*?:.*$");let matches=key.match(regex);if(matches!==null&&sigs.indexOf(matches[1])===-1)sigs.push(matches[1])});this.log("SeaSalt/Keychain purged storage keys: "+JSON.stringify(keys));if(reverse===true)Object.keys(this.keys).filter(function(csig){if(csig!==sig&&sigs.indexOf(csig)===-1)sigs.push(csig)});if(all===true){this.log("SeaSalt/Keychain purged signatures: "+
JSON.stringify(sigs));sigs.filter(function(sig){try{self.destroy(sig,history)}catch(e){}})}if(all===true&&sigs.indexOf(this.active)>-1)this.close();return{storage:keys,sigs:all===true?sigs:[]}}rekey(confirm){if(this.ready!==true||typeof this.keys[this.active]!=="object")this.error("Keychain state not ready");if(this.config.readonly===true)this.error("Keychain is in read-only mode");if(this.config.storage.enabled!==true){this.log("SeaSalt/Keychain is bypassing a rekey request because localStorage is turned off");
return}if(confirm!==true)this.error("Confirmation argument not provided");let self=this;let oldbox=this.keys[this.active].box;if(this.store_history()===false)this.error("Failed to save history key");let contents=this.gen_aead().decrypt(oldbox,this.passphrase);if(typeof contents!=="string")this.error("Box contents are invalid");let object;try{object=JSON.parse(contents)}catch(e){}if(typeof object==="object"&&!object.secret)throw"Invalid box contents detected";this.log("SeaSalt/Keychain - generating encryption key: "+
this.keys[this.active].encKey+" "+this.keys[this.active].encCipher);if(["scrypt","argon2"].indexOf(this.keys[this.active].encKey)>-1)this.log("+ "+this.keys[this.active].encKey+" may take awhile on slower machines");contents=(new SeaSalt_AEAD({cipher:this.keys[this.active].encCipher})).key(this.keys[this.active].encKey,this.tools.randomString(),this.keys[this.active].encSalt);if(typeof object==="object"){object.secret=contents;contents=JSON.stringify(object)}let newbox=(new SeaSalt_AEAD_SecretBox(this.passphrase,
contents,{key:this.active&&this.keys[this.active].encKey||this.config.encKey,salt:this.keys[this.active].encSalt||this.config.encSalt,cipher:this.keys[this.active].encCipher||this.config.encCipher})).box;let error=[];let modified=this.config.storage.list().filter(function(key){let regex=new RegExp("("+self.active+":storage:)");if(key.match(regex)!==null){let contents=self.config.storage.read(key);let decrypted;try{decrypted=self.gen_aead().decrypt(contents,self.passphrase,oldbox)}catch(e){error.push(key);
return}self.config.storage.write(key,self.gen_aead().encrypt(decrypted,self.passphrase,newbox));return true}});let codes={};for(let i=0;i<this.config.recoveryTokenCount;i++){let data=this.create_recovery(this.active);this.keys[this.active].recovery[this.hash(data.code)]=data.token;codes[data.code]=data.token}this.keys[this.active].box=newbox;if(this.save()===false)return{success:false,error:error,modified:modified,warning:"Failed to save keychain! The attached secret box is necessary for decrypting changed files.",
secretbox:this.keys[this.active].box};return{success:true,sig:this.active,codes:codes,modified:modified,error:error}}scan(userPassword,newPassword){if(this.ready!==true)this.error("Keychain state not ready");if(newPassword&&this.config.readonly===true)this.error("Keychain is in read-only mode");if(newPassword&&typeof newPassword!=="string")this.error("Password is not valid");if(newPassword&&this.tools.passwordStrength(newPassword)<this.config.minimumStrength)this.error("Password does not meet minimum strength requirements");
let self=this;let sigs={};this.listkeys().filter(function(sig){if(self.open(sig,userPassword,true)===true){if(typeof sigs[sig]==="undefined")sigs[sig]={};sigs[sig].keychain=true;sigs[sig].name=self.keys[sig].name;sigs[sig].encCipher=self.keys[sig].encCipher;sigs[sig].encKey=self.keys[sig].encKey;return}if(self.find_recovery(sig,userPassword).length>0){if(typeof sigs[sig]==="undefined")sigs[sig]={};sigs[sig].recovery=true}});if(Object.keys(sigs).length<1)return false;if(Object.keys(sigs).length>1)return sigs;
let sig=Object.keys(sigs)[0];if(sigs[sig].keychain===true){this.open(sig,userPassword);return sig}if(sigs[sig].recovery===true&&typeof newPassword==="string"&&newPassword.length>0)return this.restore_recovery(sig,userPassword,self.find_recovery(sig,userPassword),newPassword);return sigs}backup(sigs,config){let callback;if(typeof config==="object"&&typeof config.callback==="function")callback=config.callback;if(typeof config==="function")callback=config;if(typeof sigs==="function"){callback=sigs;sigs=
undefined}if(typeof sigs==="object"&&!Array.isArray(sigs)){config=sigs;sigs=undefined}if(typeof config!=="object")config={};if(typeof callback==="function")config.callback=callback;if(this.ready!==true)this.error("Keychain state not ready");if(typeof config!=="object")config={};if(typeof config.sigs==="string"||Array.isArray(config.sigs))sigs=config.sigs;if(!Array.isArray(config.sigs)&&typeof config.sigs==="object")sigs=Object.keys(config.sigs);if(typeof sigs==="string")sigs=[sigs];if(typeof sigs===
"undefined")sigs=this.listkeys();if(!Array.isArray(sigs))this.error("Invalid signatures provided");if(typeof JSZip!=="function")this.error("JSZip is required for making backups");let self=this;let zip=new JSZip;if(config.all===true)this.listkeys().filter(function(sig){if(sigs.indexOf(sig)===-1)sigs.push(sig)});sigs.filter(function(sig){let close=false;if(!Array.isArray(config.sigs)&&typeof config.sigs==="object"&&config.sigs[sig])try{self.open(sig,config.sigs[sig])}catch(e){}zip.file("keys/"+sig+
"/keyconf.json",JSON.stringify(self.keys[sig],null,5));self.config.storage.list().filter(function(key){let regex=new RegExp("^"+self.config.storage.prefix+sig+":([a-zA-Z0-9]*)(?::[0-9]*?:[0-9]*?:(.*))?$");let matches=key.match(regex);if(matches===null)return;let path;if(matches[1]==="storage"&&!Array.isArray(config.sigs)&&typeof config.sigs==="object"&&config.sigs[sig]&&self.active===sig){let data=self.decrypt(self.config.storage.read(key));try{data=JSON.parse(data)}catch(e){}if(typeof data==="object"&&
data.data&&data.meta){zip.file("keys/"+sig+"/"+matches[1]+"/"+data.meta.key.replace(/^(\/)/,"")+".json",JSON.stringify(data,null,5));return}}if(matches[1]!=="keyconf")zip.file("keys/"+sig+"/"+matches[1]+"/"+(matches[2]||key)+".enc",self.config.storage.read(key))});if(self.active===sig)self.close()});zip.file("meta.json",JSON.stringify({timestamp:Date.now(),date:(new Date).toLocaleString(),sigs:sigs},null,5));if(typeof config.callback!=="function")return zip;zip.generateAsync({type:"blob"}).then(function(content){config.callback(content)});
return true}restore(file){if(this.ready!==true)this.error("Keychain state not ready");if(this.config.readonly===true)this.error("Keychain is in read-only mode");return false}};
